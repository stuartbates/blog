---
layout: post
title:  "Blocks, Procs and Lambdas in Ruby"
date:   2023-06-27 07:32:42 +0100
categories: ruby software
published: false
---

## What is a block?

Blocks are just one member of a larger family of "callable objects", which include procs, lambdas and methods.

They allow you to write code that is packaged for execution at a later point in time.

## What is a closure?

When code runs, it needs an environment: local variables, instance variables, self etc... These entities are basically names bound to objects, you can call them bindings for short. Blocks are all inclusive and come ready to run. They contain both code and a set of bindings.

When you define the block, it simply grabs the bindings that are there at that moment and then carries those bindings along when you pass the block into a method.

A closure is code plus bindings to it's surrounding state at the point it was defined - the lexical environment.

## Procs

Proc objects are closures, meaning they remember and can use the entire context in which they were created.

```
# 1.
proc1 = Proc.new {|x| x**2 }

# 2.
proc2 = proc {|x| x**2 }

# 3.
def make_proc(&block)
  block
end

proc3 = make_proc {|x| x**2 }

# 4.
lambda1 = lambda {|x| x**2 }

# 5.
lambda2 = ->(x) { x**2 }

# 6. 
to_proc
```

## Lambdas

There is a special flavour of Procs called Lambdas. 

A lambda is still an instance of Proc simply with `is_lambda` set to `TRUE`.

The lambda-ness affects argument handling and the behavior of `return` and `break`.

A Proc object generated by `proc` ignores extra arguments.

```
proc {|a,b| [a,b] }.call(1,2,3)    #=> [1,2]
```

It provides `nil` for missing arguments.

```
proc {|a,b| [a,b] }.call(1)        #=> [1,nil]
```

It expands a single array argument.
 
```
proc {|a,b| [a,b] }.call([1,2])    #=> [1,2]
```

A Proc object generated by `lambda` doesn't have such tricks.

```
lambda {|a,b| [a,b] }.call(1,2,3)  #=> ArgumentError
lambda {|a,b| [a,b] }.call(1)      #=> ArgumentError
lambda {|a,b| [a,b] }.call([1,2])  #=> ArgumentError
```

## Why both?

- Enumerable return allowing return from enclosing method
- Blocks to be used as an argument to `define_method` which requires strict arity checking and method-like return behaviour. 

## Useful Links:
- https://github.com/ruby/ruby/blob/master/proc.c
